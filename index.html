<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rise of Inkanyamba</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body {
      background: linear-gradient(135deg, #1a202c 0%, #2d3748 50%, #1a202c 100%);
      color: #f9fafb;
      font-family: 'Press Start 2P', 'Courier New', monospace;
      min-height: 100vh;
      font-size: 0.9rem; /* Base font size */
      display: flex; /* Use flexbox for centering */
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 1rem; /* Add some padding around the edges */
      box-sizing: border-box; /* Include padding in element's total width and height */
    }
    .prose p {
      font-family: 'Press Start 2P', 'Courier New', monospace;
      font-size: 0.9rem;
      line-height: 1.5;
    }
    .fade {
      animation: fadeIn 1s ease-in-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .glow {
      text-shadow: 0 0 10px rgba(34, 197, 94, 0.5);
    }
    .hidden {
      display: none;
    }
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      padding: 10px; /* Add padding for small screens */
      box-sizing: border-box;
    }
    .modal-content {
      background: #1a202c;
      border: 2px solid #2d3748;
      padding: 2rem;
      border-radius: 8px;
      max-width: 90%;
      max-height: 90%;
      overflow-y: auto;
      box-shadow: 0 0 20px rgba(34, 197, 94, 0.5);
      box-sizing: border-box;
    }

    /* Game Container Responsiveness */
    #game-container {
      /* Removed fixed width/height */
      max-width: 100%; /* Ensure it doesn't exceed screen width */
      max-height: 100vh; /* Ensure it doesn't exceed viewport height */
      aspect-ratio: 4 / 3; /* Maintain 4:3 aspect ratio (800/600) */
      width: 800px; /* Preferred width for larger screens, will scale down */
      margin-left: auto; /* Center the container */
      margin-right: auto; /* Center the container */

      /* Existing Tailwind-like styles from original HTML */
      position: relative;
      background-color: #1a202c; /* Equivalent to Tailwind bg-gray-900 */
      border: 4px solid #22c55e; /* Equivalent to Tailwind border-green-500 */
      border-radius: 0.5rem; /* Equivalent to Tailwind rounded-lg */
      box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05); /* Equivalent to Tailwind shadow-lg */
      overflow: hidden;
    }

    /* Canvas inside the container */
    #game {
      display: block; /* Remove extra space below canvas */
      width: 100%; /* Make canvas fill its container's width */
      height: 100%; /* Make canvas fill its container's height */
      /* These properties help keep pixel art crisp when scaled */
      image-rendering: optimizeSpeed; /* Older property for crispness */
      image-rendering: -moz-crisp-edges; /* Firefox */
      image-rendering: -webkit-optimize-contrast; /* Webkit */
      image-rendering: pixelated; /* Modern property for pixel art */
      -ms-interpolation-mode: nearest-neighbor; /* IE (unlikely needed) */
    }

    /* Media queries for smaller screens to adjust text/UI elements */
    @media (max-width: 800px) { /* For screens up to 800px wide */
      body {
        font-size: 0.8rem; /* Slightly smaller base font */
      }
      .text-4xl { /* Adjust overlay title size */
        font-size: 2.5rem !important; /* Tailwind `text-4xl` is 2.25rem by default, but !important for safety */
      }
      .text-lg { /* Adjust overlay message size */
        font-size: 1rem !important; /* Tailwind `text-lg` is 1.125rem by default */
      }
      .px-6 { /* Adjust button padding */
        padding-left: 1rem !important;
        padding-right: 1rem !important;
      }
      .py-3 {
        padding-top: 0.75rem !important;
        padding-bottom: 0.75rem !important;
      }
      .modal-content {
        padding: 1.5rem; /* Slightly reduced modal padding */
      }
      .text-3xl { /* Inventory title */
          font-size: 2rem !important;
      }
      #inventory-list { /* More flexible inventory grid for smaller screens */
          grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
          gap: 0.5rem;
      }
      .text-xs { /* Item name in inventory */
          font-size: 0.65rem !important;
      }
    }

    @media (max-width: 480px) { /* For very small mobile screens */
      body {
        font-size: 0.7rem;
      }
      .text-4xl {
        font-size: 2rem !important;
      }
      .text-lg {
        font-size: 0.9rem !important;
      }
      .modal-content {
          padding: 1rem;
      }
      #inventory-list {
          grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
      }
      .text-sm { /* Instructions text */
          font-size: 0.7rem !important;
      }
    }
  </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

  <div id="game-container" class="relative bg-gray-900 border-4 border-green-500 rounded-lg shadow-lg overflow-hidden">
    <canvas id="game" class="block w-full h-full"></canvas>

    <div id="overlay" class="absolute inset-0 bg-gray-900 bg-opacity-90 flex flex-col items-center justify-center text-center text-white p-4 hidden">
      <h2 id="overlay-title" class="text-4xl font-bold text-green-400 mb-4 fade"></h2>
      <p id="overlay-message" class="text-lg mb-6 fade prose"></p>
      <button id="overlay-button" class="px-6 py-3 bg-green-600 hover:bg-green-700 text-white font-bold rounded-lg shadow-lg transition-all duration-300 transform hover:scale-105 fade hidden">
        Start Game
      </button>
    </div>

    <div id="inventory-modal" class="modal-overlay hidden">
        <div class="modal-content w-4/5 md:w-3/5 lg:w-1/2">
            <h3 class="text-3xl font-bold text-green-400 mb-6 text-center">Inventory</h3>
            <div id="inventory-list" class="grid grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 mb-6">
                </div>
            <div id="item-details" class="bg-gray-800 p-4 rounded-lg border border-gray-700 min-h-[100px] flex items-center justify-center text-center">
                <p class="text-gray-400">Select an item to see its details.</p>
            </div>
            <button id="close-inventory-btn" class="mt-8 px-6 py-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg shadow-lg transition-all duration-300 transform hover:scale-105 block mx-auto">
                Close
            </button>
        </div>
    </div>
  </div>

  <div class="text-sm mt-4 text-gray-400">
    Use Arrow Keys to Move, Space to Attack, I for Inventory.
  </div>

  <script>
    // --- Game Setup ---
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // Make gameEl a global variable if needed elsewhere
    let gameEl;

    // Game state variables
    let score = 0;
    let gameOver = false;
    let gameStarted = false;
    let inventory = [];
    const INVENTORY_CAPACITY = 8; // Max items
    let itemDetailsEl; // Globally accessible for displayItemDetails
    let inventoryListEl; // Globally accessible for showInventoryModal

    const GRID_SIZE = 40; // Size of each grid cell (e.g., 40x40 pixels)
    const PLAYER_SPEED = 4; // Pixels per frame
    const ENEMY_SPEED = 2;

    // Asset loading progress
    let assetsLoaded = 0;
    const totalAssets = 8; // Adjust based on your actual assets (initial 8)

    // Image assets (Initial set)
    const playerSprite = new Image();
    playerSprite.src = 'img/Gemini_Generated_Image_3n2k8r3n2k8r3n2k.png';
    playerSprite.onload = () => assetsLoaded++;

    const enemySprite = new Image();
    enemySprite.src = 'img/Gemini_Generated_Image_53oz4i53oz4i53oz.png';
    enemySprite.onload = () => assetsLoaded++;

    const itemSpriteHealth = new Image();
    itemSpriteHealth.src = 'img/Gemini_Generated_Image_oxorcpoxorcpoxor.png';
    itemSpriteHealth.onload = () => assetsLoaded++;

    const itemSpriteKey = new Image();
    itemSpriteKey.src = 'img/Gemini_Generated_Image_vhqsy1vhqsy1vhqs.png';
    itemSpriteKey.onload = () => assetsLoaded++;

    const itemSpriteWeapon = new Image();
    itemSpriteWeapon.src = 'img/Gemini_Generated_Image_vhqsy5vhqsy5vhqs.png';
    itemSpriteWeapon.onload = () => assetsLoaded++;

    const backgroundSprite = new Image();
    backgroundSprite.src = 'img/Gemini_Generated_Image_53oz4m53oz4m53oz.png';
    backgroundSprite.onload = () => assetsLoaded++;

    const attackEffectSprite = new Image();
    attackEffectSprite.src = 'img/Gemini_Generated_Image_oxorcroxorcroxor.png';
    attackEffectSprite.onload = () => assetsLoaded++;

    const doorSprite = new Image();
    doorSprite.src = 'img/Gemini_Generated_Image_oxorcooxorcooxor.png';
    doorSprite.onload = () => assetsLoaded++;

    // Game objects
    const player = {
      x: 50,
      y: 50,
      width: GRID_SIZE,
      height: GRID_SIZE,
      dx: 0,
      dy: 0,
      speed: PLAYER_SPEED,
      health: 100,
      maxHealth: 100,
      attackDamage: 10,
      isAttacking: false,
      attackTimer: 0,
      attackDuration: 20, // frames
      sprite: playerSprite,
    };

    let enemies = [];
    let items = [];

    // Player Ancestry Data
    const playerAncestries = {
      // Image paths for player ancestries (now using relative paths)
      images: {
        "Sangoma": "img/sangoma Gemini_Generated_Image_7ukgbq7ukgbq7ukg.png",
        "Umkhosi Warrior": "img/Worior Gemini_Generated_Image_7ukgbo7ukgbo7ukg.png",
        "Ghostwalker": "img/Ghost Gemini_Generated_Image_7ukgbp7ukgbp7ukg.png",
        "Serpent Caller": "img/serpant caller Gemini_Generated_Image_7ukgbr7ukgbr7ukg.png"
      }
    };
    let enemy = null;
    let currentLocation = "";
    let typingInterval; // Variable to hold the interval ID for typing effect
    const typingSpeed = 30; // Milliseconds per character for typing effect

    // Image paths for enemies (now using relative paths)
    const enemyImages = {
      "Shadow Hyena": "img/Shadow Hyena Gemini_Generated_Image_r9tql2r9tql2r9tq.png",
      "Pack of Shadow Jackals": "img/Pack of Shadow Jackals Gemini_Generated_Image_145ly9145ly9145l.png",
      "Thunder Eagle": "img/Thunder Eagle Gemini_Generated_Image_685duy685duy685d.png",
      "Inkanyamba, The Storm Serpent": "img/Inkanyamba Gemini_Generated_Image_oxorcpoxorcpoxor.png"
    };

    // --- Item Data ---
    const gameItems = {
      "Healing Herbs": {
        description: "Common herbs with mild healing properties.",
        effect: "Restores a small amount of HP.",
        imageUrl: "img/Healing Herbs Gemini_Generated_Image_hc61u2hc61u2hc61.png"
      },
      "War Spear": {
        description: "A sturdy spear, good for close combat.",
        effect: "Used by Umkhosi Warriors. Enhances Strength.",
        imageUrl: "img/War Spear Gemini_Generated_Image_wmyjj8wmyjj8wmyj.png"
      },
      "Shadow Cloak": {
        description: "A cloak woven from shadow, granting stealth and agility.",
        effect: "Used by Ghostwalkers. Enhances Wisdom.",
        imageUrl: "img/Shadow Cloak.png"
      },
      "Snake Charm": {
        description: "An ancient charm that resonates with nature's spirits.",
        effect: "Used by Serpent Callers. Enhances Spirit and Wisdom.",
        imageUrl: "img/Snake Charm.png"
      },
      "Ancient Knowledge": {
        description: "Fragments of forgotten lore.",
        effect: "Increases Spirit stat.",
        imageUrl: "img/Ancient Knowledge.png"
      },
      "Spirit Idol": {
        description: "A small carved idol pulsing with ethereal energy.",
        effect: "Can be used in combat to deal spiritual damage.",
        imageUrl: "img/Spirit Idol.png"
      },
      "Shadow Fang": {
        description: "A sharp fang from a shadow beast.",
        effect: "Valuable loot, can be sold or used in crafting (future feature).",
        imageUrl: "img/Shadow Fang.png"
      },
      "Dark Essence": {
        description: "A vial of concentrated shadow energy.",
        effect: "Valuable loot, potentially useful for dark rituals (future feature).",
        imageUrl: "img/Dark Essence.png"
      },
      "Beast Claw": {
        description: "A formidable claw from a defeated beast.",
        effect: "Valuable loot.",
        imageUrl: "img/Beast Claw.png"
      },
      "Mystic Bone": {
        description: "A bone inscribed with faint mystic runes.",
        effect: "Valuable loot, holds unknown power.",
        imageUrl: "img/Mystic Bone.png"
      },
      "Protective Charm": {
        description: "A charm blessed by village elders.",
        effect: "Temporarily increases defense in combat when used.",
        imageUrl: "img/Protective Charm.jpg"
      },
      "Lightning Rod": {
        description: "An ornate copper rod that channels storm energy.",
        effect: "Powerful against elemental foes in combat.",
        imageUrl: "img/Lightning Rod.png"
      },
      "Medicinal Herbs": {
        description: "Potent herbs for healing.",
        effect: "Can be brewed into stronger concoctions or used to heal.",
        imageUrl: "img/medicinal herbs.png"
      },
      "Healing Potion": {
        description: "A brewed potion that restores a significant amount of health.",
        effect: "Restores a significant amount of HP when used.",
        imageUrl: "img/Healing Potion.png"
      },
      "Ancestral Blessing": {
        description: "A powerful blessing from the ancestors.",
        effect: "Grants spiritual fortitude.",
        imageUrl: "img/Ancestral Blessing.png"
      },
      "Shard of Ancient Power": {
        description: "A glowing fragment of a long-lost artifact.",
        effect: "Its purpose is yet unknown, but it hums with energy.",
        imageUrl: "img/Shard of Ancient Power.png"
      },
      "Glowcap Mushroom": {
        description: "A bioluminescent mushroom found in dark caves.",
        effect: "Provides light and minor healing properties.",
        imageUrl: "img/Glowcap Mushroom.png"
      },
      "Forest Berries": {
        description: "Sweet, wild berries.",
        effect: "Offer a small amount of sustenance and healing.",
        imageUrl: "img/Forest berries.png"
      },
      "Dreampetal": {
        description: "A delicate, shimmering flower.",
        effect: "Consuming it enhances mental clarity and wisdom.",
        imageUrl: "img/Dreampetal.png"
      }
    };


    // Placeholder for obstacles/walls (not implemented in drawing yet)
    let obstacles = [];

    // --- Input Handling ---
    let keys = {};
    document.addEventListener('keydown', (e) => {
      keys[e.key] = true;
    });
    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    // Event listener for opening/closing inventory
    document.addEventListener('keydown', (e) => {
        if (e.key === 'i' || e.key === 'I') {
            const modal = document.getElementById('inventory-modal');
            if (modal.classList.contains('hidden')) {
                showInventoryModal();
            } else {
                hideInventoryModal();
            }
        }
    });

    // Event listener for closing inventory modal
    document.addEventListener('DOMContentLoaded', () => {
        itemDetailsEl = document.getElementById('item-details');
        inventoryListEl = document.getElementById('inventory-list');

        const closeBtn = document.getElementById('close-inventory-btn');
        if (closeBtn) {
            closeBtn.addEventListener('click', hideInventoryModal);
        } else {
            console.error("Close inventory button not found!");
        }
    });


    // --- Game Logic ---
    function spawnEnemy() {
      const x = Math.random() * (canvas.width - GRID_SIZE);
      const y = Math.random() * (canvas.height - GRID_SIZE);
      enemies.push({
        x: x,
        y: y,
        width: GRID_SIZE,
        height: GRID_SIZE,
        health: 50,
        attackDamage: 5,
        sprite: enemySprite, // Assuming enemySprite is defined and loaded for generic enemies
      });
    }

    function spawnItem() {
      const itemNames = Object.keys(gameItems);
      const randomItemName = itemNames[Math.floor(Math.random() * itemNames.length)];
      const itemData = gameItems[randomItemName];

      const x = Math.random() * (canvas.width - GRID_SIZE);
      const y = Math.random() * (canvas.height - GRID_SIZE);
      // Create a new Image object for the item sprite based on its imageUrl
      const itemImage = new Image();
      itemImage.src = itemData.imageUrl;
      itemImage.onload = () => assetsLoaded++; // Increment assetsLoaded for dynamically loaded items

      items.push({
        x: x,
        y: y,
        width: GRID_SIZE,
        height: GRID_SIZE,
        type: randomItemName,
        sprite: itemImage // Assign the dynamically loaded image
      });
    }

    function update() {
      if (gameOver || !gameStarted) return;

      // Player movement
      player.dx = 0;
      player.dy = 0;
      if (keys['ArrowUp']) player.dy = -player.speed;
      if (keys['ArrowDown']) player.dy = player.speed;
      if (keys['ArrowLeft']) player.dx = -player.speed;
      if (keys['ArrowRight']) player.dx = player.speed;

      player.x += player.dx;
      player.y += player.dy;

      // Keep player within bounds
      player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
      player.y = Math.max(0, Math.min(canvas.height - player.height, player.y));

      // Player attack
      if (keys[' ']) { // Spacebar
        player.isAttacking = true;
        player.attackTimer = player.attackDuration;
      }

      if (player.isAttacking) {
        player.attackTimer--;
        if (player.attackTimer <= 0) {
          player.isAttacking = false;
        }
      }

      // Update enemies
      enemies.forEach(enemy => {
        // Simple enemy movement: move towards player
        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
        enemy.x += Math.cos(angle) * ENEMY_SPEED;
        enemy.y += Math.sin(angle) * ENEMY_SPEED;

        // Enemy-player collision (damage)
        if (checkCollision(player, enemy)) {
          player.health -= enemy.attackDamage / 60; // Damage over time
          if (player.health <= 0) {
            endGame();
          }
        }

        // Player attack collision with enemy
        if (player.isAttacking && checkCollision(player, enemy)) {
          enemy.health -= player.attackDamage;
          if (enemy.health <= 0) {
            // Remove defeated enemy
            enemies = enemies.filter(e => e !== enemy);
            score += 10;
          }
        }
      });

      // Item collision
      items.forEach(item => {
        if (checkCollision(player, item)) {
          if (inventory.length < INVENTORY_CAPACITY) {
            inventory.push(item.type); // Add item name to inventory
            items = items.filter(i => i !== item); // Remove collected item
            console.log(`Collected ${item.type}! Inventory:`, inventory);
          } else {
            console.log("Inventory is full!");
          }
        }
      });
    }

    function checkCollision(obj1, obj2) {
      return obj1.x < obj2.x + obj2.width &&
             obj1.x + obj1.width > obj2.x &&
             obj1.y < obj2.y + obj2.height &&
             obj1.y + obj1.height > obj2.y;
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

      // Draw background
      if (backgroundSprite.complete && backgroundSprite.naturalWidth !== 0) {
        ctx.drawImage(backgroundSprite, 0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = '#333'; // Fallback color
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }


      // Draw enemies
      enemies.forEach(enemy => {
        if (enemy.sprite.complete && enemy.sprite.naturalWidth !== 0) { // Check if enemy sprite is loaded
            ctx.drawImage(enemy.sprite, enemy.x, enemy.y, enemy.width, enemy.height);
        } else {
            // Fallback: draw a colored rectangle if sprite not loaded
            ctx.fillStyle = 'purple';
            ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
        }

        // Draw enemy health bar
        ctx.fillStyle = 'red';
        ctx.fillRect(enemy.x, enemy.y - 10, enemy.width, 5);
        ctx.fillStyle = 'green';
        ctx.fillRect(enemy.x, enemy.y - 10, enemy.width * (enemy.health / 50), 5);
      });

      // Draw items
      items.forEach(item => {
        if (item.sprite.complete && item.sprite.naturalWidth !== 0) { // Check if item sprite is loaded
            ctx.drawImage(item.sprite, item.x, item.y, item.width, item.height);
        } else {
            // Fallback: draw a colored rectangle if sprite not loaded
            ctx.fillStyle = 'blue';
            ctx.fillRect(item.x, item.y, item.width, item.height);
        }
      });

      // Draw player
      ctx.drawImage(player.sprite, player.x, player.y, player.width, player.height);

      // Draw attack effect (if attacking)
      if (player.isAttacking) {
        // This is a placeholder for a visual attack effect
        ctx.drawImage(attackEffectSprite, player.x + player.width / 2 - 15, player.y + player.height / 2 - 15, 30, 30);
      }

      // Draw UI
      ctx.fillStyle = 'white';
      ctx.font = '16px "Press Start 2P"';
      ctx.fillText(`Score: ${score}`, 10, 20);
      ctx.fillText(`Health: ${Math.max(0, Math.floor(player.health))}`, 10, 40);
    }

    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function showOverlay(title, message, buttonText = '', showButton = false) {
      const overlay = document.getElementById('overlay');
      const overlayTitle = document.getElementById('overlay-title');
      const overlayMessage = document.getElementById('overlay-message');
      const overlayButton = document.getElementById('overlay-button');

      overlayTitle.textContent = title;
      overlayMessage.innerHTML = message; // Use innerHTML to allow for simple HTML like <br>
      overlayButton.textContent = buttonText;

      if (showButton) {
        overlayButton.classList.remove('hidden');
      } else {
        overlayButton.classList.add('hidden');
      }

      overlay.classList.remove('hidden');
    }

    function hideOverlay() {
      document.getElementById('overlay').classList.add('hidden');
    }

    function startGame() {
      // Adjusted totalAssets to account for the new sets of images
      // Count images in playerAncestries, enemyImages, and gameItems that are NOT pre-loaded
      // You'll need to manually adjust `totalAssets` to the exact number of images your game uses.
      // The current `totalAssets = 8` only accounts for the initial set (player, enemy, etc.).
      // If images from playerAncestries, enemyImages, and gameItems are loaded dynamically,
      // you need to ensure they are also counted or handled differently.
      // For now, I've added a check for sprite.complete in draw() for safety.

      // A more robust loading system would count all images and wait for them to load.
      // For simplicity, for now, let's assume all main images are pre-loaded.
      // If you're loading enemies/items dynamically, consider adding their .onload to a counter.
      // Here, I'm just keeping the initial `totalAssets = 8` as per your original file structure.

      if (assetsLoaded < totalAssets) {
        showOverlay("Loading...", "Please wait while game assets load.<br>(" + assetsLoaded + "/" + totalAssets + " loaded)", "", false);
        requestAnimationFrame(startGame); // Keep checking
        return;
      }

      hideOverlay();
      gameStarted = true;
      score = 0;
      player.health = player.maxHealth;
      enemies = [];
      items = [];
      inventory = []; // Clear inventory on new game
      player.attackDamage = 10; // Reset attack damage

      // Spawn initial enemies and items
      for (let i = 0; i < 3; i++) spawnEnemy();
      for (let i = 0; i < 2; i++) spawnItem();

      loop(); // Start game loop
      // Set intervals for spawning new enemies/items
      setInterval(spawnEnemy, 10000); // Every 10 seconds
      setInterval(spawnItem, 15000); // Every 15 seconds
    }

    function endGame() {
      gameOver = true;
      showOverlay(
        "Game Over!",
        `You have been defeated! Your final score is: ${score}`,
        "Play Again",
        true
      );
      document.getElementById('overlay-button').onclick = () => {
        gameOver = false;
        startGame();
      };
    }

    // Initial call to display start screen or loading
    document.addEventListener("DOMContentLoaded", () => {
      // Set canvas dimensions explicitly for game logic
      canvas.width = 800;
      canvas.height = 600;

      showOverlay(
        "Rise of Inkanyamba",
        "A mystical creature threatens the land. Collect items, defeat enemies, and survive!",
        "Start Game",
        true
      );
      document.getElementById('overlay-button').onclick = () => {
        // Ensure gameEl is set before starting the game
        gameEl = document.getElementById("game");
        if (!gameEl) {
          console.error("Game element (id='game') not found! Script cannot proceed.");
          return;
        }
        startGame();
      };
    });

    /**
     * Displays the inventory modal with current items.
     */
    function showInventoryModal() {
        const modal = document.getElementById('inventory-modal');
        // Clear previous item details
        itemDetailsEl.innerHTML = `<p class="text-gray-400">Select an item to see its details.</p>`;
        inventoryListEl.innerHTML = ''; // Clear existing slots

        if (inventory.length === 0) {
            inventoryListEl.innerHTML = '<p class="col-span-full text-center text-gray-400">Your inventory is empty.</p>';
        }

        // Populate inventory slots
        inventory.forEach(itemName => {
            const itemData = gameItems[itemName];
            if (itemData) {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'bg-gray-800 p-2 rounded-lg border border-gray-700 hover:border-green-500 cursor-pointer transition-colors duration-200 flex flex-col items-center justify-center';
                itemDiv.innerHTML = `
                    <img src="${itemData.imageUrl}" alt="${itemName}" class="w-12 h-12 mb-1 image-rendering-pixelated">
                    <span class="text-xs text-center">${itemName}</span>
                `;
                itemDiv.onclick = () => displayItemDetails(itemName);
                inventoryListEl.appendChild(itemDiv);
            }
        });

        // Add empty slots
        for (let i = inventory.length; i < INVENTORY_CAPACITY; i++) {
            const emptySlotDiv = document.createElement('div');
            emptySlotDiv.className = 'bg-gray-700 p-2 rounded-lg border border-gray-600 flex items-center justify-center text-gray-500';
            emptySlotDiv.innerHTML = '<span class="text-2xl">+</span>'; // Placeholder for empty slot
            inventoryListEl.appendChild(emptySlotDiv);
        }

        modal.classList.remove('hidden');
    }

    /**
     * Hides the inventory modal.
     */
    function hideInventoryModal() {
        const modal = document.getElementById('inventory-modal');
        modal.classList.add('hidden');
    }

    /**
     * Displays details for a selected item in the inventory modal.
     * @param {string} itemName - The name of the item to display details for.
     */
    function displayItemDetails(itemName) {
        // itemDetailsEl is now accessible globally
        const itemData = gameItems[itemName];

        if (itemData) {
            itemDetailsEl.innerHTML = `
                <h4 class="text-xl font-bold text-green-300 mb-2">${itemName}</h4>
                <p class="mb-2">${itemData.description}</p>
                <p class="text-sm text-gray-300"><strong>Effect:</strong> ${itemData.effect}</p>
            `;
        } else {
            itemDetailsEl.innerHTML = `<p>No details available for "${itemName}".</p>`;
        }
    }


    // This event listener should still be present to ensure gameEl is found
    // and startGame() is called only after the HTML content is fully loaded.
    document.addEventListener("DOMContentLoaded", () => {
      gameEl = document.getElementById("game");
      if (!gameEl) {
        console.error("Game element (id='game') not found! Script cannot proceed.");
        return;
      }
      startGame();
    });
  </script>
</body>
</html>
